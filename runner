#!/bin/env fennel
;; -*- mode: fennel -*-

(local fennel (require :fennel))
(local config {:seed (tonumber (or (os.getenv "FENNEL_TEST_SEED") (os.time)))
               :reporter :dots
               :shuffle? true})
(local tests [])
(local fixtures {:once {} :each {}})
(local errors [])

(local dots
  {:ns-start (fn [] (io.stdout:write "("))
   :ns-report (fn [] (io.stdout:write ")"))
   :test-start (fn [] nil)
   :test-report (fn [ok? test-name msg]
                  (io.stdout:write (if ok? "." "F")))
   :stats-report (fn [] (io.stdout:write "\n"))})

(local namespaces
  {:ns-start (fn [ns] (io.stdout:write ns ": "))
   :ns-report (fn [ns ok?] (io.stdout:write (if ok? "PASS" "FAIL")))
   :test-start (fn [] nil)
   :test-report (fn [] nil)
   :stats-report (fn [] nil)})

(fn file-exists? [file]
  (let [fh (io.open file)]
    (when fh (fh:close))
    (not= fh nil)))

(fn setup-runner []
  (when (file-exists? ".fennel-test")
    (match (pcall fennel.dofile :.fennel-test)
      (true rc) (each [k v (pairs rc)]
                  (tset config k v))
      (false msg) (do
                    (io.stderr:write msg "\n")
                    (os.exit 1))))
  (if (= config.reporter :dots)
      (set config.reporter dots)
      (= config.reporter :namespaces)
      (set config.reporter namespaces)
      (and (= :table (type config.reporter))
           (= :function config.reporter.ns-start)
           (= :function config.reporter.ns-report)
           (= :function config.reporter.test-start)
           (= :function config.reporter.test-report)
           (= :function config.reporter.stats-report))
      nil
      (not= nil config.reporter)
      (do (io.stderr:write
           "Warning: unknown or malformed reporter: "
           (fennel.view config.reporter)
           "\n Using default: dots\n")
          (set config.reporter dots)))
  config)

(fn module-from-file [file]
  (let [sep (package.config:sub 1 1)
        module (-> file
                   (string.gsub sep ".")
                   (string.gsub "%.fnl$" ""))]
    module))

(fn deepcopy [x]
  ((fn deepcopy [x seen]
     (match  (type x)
       :table (match (. seen x)
                x* x*
                _ (let [res {}]
                    (tset seen x res)
                    (each [k v (pairs x)]
                      (tset res
                            (deepcopy k seen)
                            (deepcopy v seen)))
                    (setmetatable res (getmetatable x))))
       _ x))
   x {}))

(fn load-tests []
  (let [g _G]
    (each [_ file (ipairs arg)]
      (let [module-name (module-from-file file)
            module-tests []]
        (set-forcibly! _G (deepcopy _G))
        (table.insert tests [module-name module-tests])
        (fennel.dofile file {:env _G} module-name module-tests fixtures)))
    (set-forcibly! _G g)))

(fn default-fixture [f]
  (f))

(fn compose-fixtures [f1 f2]
  (fn [g] (f1 (fn [] (f2 g)))))

(fn join-fixtures [fixtures]
  (accumulate [f default-fixture _ fixture (ipairs fixtures)]
    (compose-fixtures f fixture)))

(fn setup-fixtures [once-each]
  (each [ns fs (pairs (. fixtures once-each))]
    (tset fixtures once-each ns (join-fixtures fs))))

(macro with-no-output [expr]
  "Suppress output to stderr."
  `(let [stdout-mt# (. (getmetatable io.stdout) :__index)
         write# stdout-mt#.write
         pack# #(doto [$...] (tset :n (select "#" $...)))]
     (tset stdout-mt# :write (fn [fd# ...]
                               (when (and (not= fd# io.stdout)
                                          (not= fd# io.stderr))
                                 (write# fd# ...))))
     (let [res# (pack# ,expr)]
       (tset stdout-mt# :write write#)
       (table.unpack res# 1 res#.n))))

(fn run-ns-tests [ns tests]
  (config.reporter.ns-start ns)
  (var ok? true)
  (let [oncef (or (. fixtures.once ns) default-fixture)]
    (oncef
     (fn []
       (let [eachf (or (. fixtures.each ns) default-fixture)]
         (each [_ [test-name test-fn] (ipairs tests)]
           (config.reporter.test-start ns test-name)
           (match (with-no-output (pcall eachf test-fn))
             (false msg) (do (set ok? false)
                             (config.reporter.test-report false ns test-name msg)
                             (table.insert errors [ns test-name msg]))
             _ (config.reporter.test-report true ns test-name)))))))
  (config.reporter.ns-report ns ok?))

(fn run-tests []
  (each [_ [ns tests] (ipairs tests)]
    (run-ns-tests ns tests))
  (config.reporter.stats-report))

(fn print-errors []
  (each [_ [ns test-name message] (ipairs errors)]
    (io.stderr:write "Error in " ns " in test " test-name ":\n" message "\n")))

(fn shuffle-table [t]
  (for [i (length t) 2 -1]
    (let [j (math.random i)
          ti (. t i)]
      (tset t i (. t j))
      (tset t j ti))))

(fn shuffle-tests []
  (each [_ [_ test-ns] (ipairs tests)]
    (shuffle-table test-ns))
  (shuffle-table tests))

(fn print-stats []
  (io.stdout:write "Test run at " (os.date) ", seed: " config.seed "\n"))

(setup-runner)
(print-stats)
(load-tests)
(setup-fixtures :once)
(setup-fixtures :each)
(when config.shuffle?
  (shuffle-tests))
(run-tests)
(print-errors)

(when (> (length errors) 0)
  (os.exit 1))
